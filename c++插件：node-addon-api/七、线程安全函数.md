# 线程安全函数

## 线程安全函数API

### New

线程安全函数保证了nodejs、插件的线程安全。通过`Napi::ThreadSafeFunction:New`来创建插件的线程安全函数：

```c++
New(
    // env
    napi_env env,
    // 从主线程传入的 js callback
    const Function& callback,
    // 与异步工作相关联的对象，该对象将传递给可能的async_hooks init钩子。
    const Object& resource,
    // 可选，一个JavaScript字符串，用于为async_hooks API公开的诊断信息提供的资源类型提供标识符。
    ResourceString resourceName,
    // 队列的最大大小。0表示无限制。
    size_t maxQueueSize,
    // 将使用此函数的初始线程数，包括主线程
    size_t initialThreadCount,
    // 可选 要附加到生成的ThreadSafeFunction的数据。可以通过调用GetContext（）来检索它
    ContextType* context,
    // 可选 销毁ThreadSafeFunction时要调用的函数
    Finalizer finalizeCallback,
    // 可选 要传递给finalizeCallback的数据
    FinalizerDataType* data);
```

### Acquire

```c++
napi_status Napi::ThreadSafeFunction::Acquire() const
```

返回`napi_ok`或`napi_closeing`：

- `napi_ok`： 线程已经成功获取线程函数
- `napi_closing`：线程安全函数已通过先前对Abort（）的调用标记为关闭。

### Release

```c++
napi_status Napi::ThreadSafeFunction::Release() const
```

现有线程将停止使用线程安全功能。

### Abort

```c++
napi_status Napi::ThreadSafeFunction::Abort() const
```

终止线程安全功能。这将导致与线程安全函数关联的所有后续API（`Release()`除外）返回`napi_closing`，

返回`napi_ok`、`napi_invalid_arg`或`napi_generic_failure`。

### BlockingCall / NonBlockingCall

以阻塞或者非阻塞的方式调用js函数。

```c++
napi_status Napi::ThreadSafeFunction::BlockingCall(DataType* data, Callback callback) const

napi_status Napi::ThreadSafeFunction::NonBlockingCall(DataType* data, Callback callback) const
```

- `BlockingCall`：API会一直阻塞，直到队列中有可用空间。如果创建的线程安全函数的最大队列大小为0，则永远不会阻塞
- `NonBlockingCall`：如果队列已满，将返回`napi_queue_full`，从而阻止数据成功添加到队列

下面我们以一个简单的例子来看看怎么使用`Napi::ThreadSafeFunction`。

## `Napi::ThreadSafeFunction`应用



















































