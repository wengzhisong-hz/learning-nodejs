"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[222],{470:(e,l,r)=>{r.r(l),r.d(l,{data:()=>a});const a={key:"v-5237082a",path:"/sourceCode/buffer.html",title:"buffer",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"node & js 中 buffer 的区别",slug:"node-js-中-buffer-的区别",children:[]},{level:2,title:"buffer & cache",slug:"buffer-cache",children:[]},{level:2,title:"创建 buffer",slug:"创建-buffer",children:[{level:3,title:"中文乱码问题",slug:"中文乱码问题",children:[]}]},{level:2,title:"buffer 内存分配原理",slug:"buffer-内存分配原理",children:[{level:3,title:"Buddy",slug:"buddy",children:[]},{level:3,title:"Slab",slug:"slab",children:[]}]}],filePathRelative:"sourceCode/buffer.md",git:{updatedTime:1632633492e3,contributors:[{name:"sp0140(陆抗)",email:"wengzs@supaur.com",commits:1}]}}},38:(e,l,r)=>{r.r(l),r.d(l,{default:()=>i});const a=(0,r(252).uE)('<h1 id="buffer" tabindex="-1"><a class="header-anchor" href="#buffer" aria-hidden="true">#</a> buffer</h1><h2 id="node-js-中-buffer-的区别" tabindex="-1"><a class="header-anchor" href="#node-js-中-buffer-的区别" aria-hidden="true">#</a> node &amp; js 中 buffer 的区别</h2><blockquote><p><code>ArrayBuffer</code>对象代表原始的二进制数据 <code>TypedArray</code>视图用来读写简单类型的二进制数据（ArrayBuffer），<code>DataView</code>视图用来读写复杂类型的二进制数据(ArrayBuffer)。 Node 中的<code>Buffer</code>类是以更优化和更适合 Nodejs 的方式实现了<code>Uint8Array</code> API，意思就是<code>Buffer</code>类其实是<code>TypedArray(Uint8Array)</code>的 nodejs 实现。</p></blockquote><h2 id="buffer-cache" tabindex="-1"><a class="header-anchor" href="#buffer-cache" aria-hidden="true">#</a> buffer &amp; cache</h2><p>buffer 的目的是起到流量整形的作用，减少短期内突发 I/O 的影响。</p><p>cache 是处理系统两端处理速度不匹配的情况，比如磁盘、内存、cpu 处理速度不一样，所以会有各种缓存技术。cache 中的数据是可以重复获取的。</p><h2 id="创建-buffer" tabindex="-1"><a class="header-anchor" href="#创建-buffer" aria-hidden="true">#</a> 创建 buffer</h2><ol><li>Blob 类 <ol><li>Blob 封装了不可变数据，可以在多个工作线程中安全地共享，v15 新增</li><li>使用 <code>new buffer.Blob(source, opts)</code> 创建</li></ol></li><li>Buffer 类 <ol><li><code>alloc(size, fill = 0, encoding = &#39;utf8&#39;)</code></li><li><code>allocUnsafe(size)</code></li><li><code>allocUnsafeSlow(size)</code></li><li><code>from()</code><ol><li>array、arrayBuffer、buffer、object、string</li></ol></li></ol></li><li>字符编码默认使用<code>utf8</code><ol><li>支持<code>utf8 utf16le latin1 base64 base64url hex ascii latin1 binary</code></li></ol></li><li>使用 <code>for...of</code> 遍历 buffer</li></ol><h3 id="中文乱码问题" tabindex="-1"><a class="header-anchor" href="#中文乱码问题" aria-hidden="true">#</a> 中文乱码问题</h3><p>中文字符在<code>utf8</code>中占 3 个字节。</p><p>需要设置 stream 的编码方式为<code>utf8</code>。通过<code>setEncoding</code> 设置的 buffer，在被处理的时候已经转为中文字符串了。</p><h2 id="buffer-内存分配原理" tabindex="-1"><a class="header-anchor" href="#buffer-内存分配原理" aria-hidden="true">#</a> buffer 内存分配原理</h2><p>node 采用 slab 机制进行内存分配。</p><h3 id="buddy" tabindex="-1"><a class="header-anchor" href="#buddy" aria-hidden="true">#</a> Buddy</h3><blockquote><p>内存从一个 2 的 N 次幂大的内存块中分配。当内存块比要分配的长度大两倍以上，内存块平均分裂成两块。选中其中一半，重复这个过程（检查长度，满足条件则分裂）直到内存块刚好等于需要的长度。</p><p>所有的块信息保存在一个排序过的链表或者二叉树中。当一个块被释放的时候与他的相邻块进行比较。如果他们都被释放，就合并成一个大块放进更大的一个块列表 中。每当分配结束，分配器会从尽量小的块重新开始分配，以避免产生不必要的碎片。</p></blockquote><h3 id="slab" tabindex="-1"><a class="header-anchor" href="#slab" aria-hidden="true">#</a> Slab</h3><p>专注于小内存分配。与 buddy 互相配合。</p><ol><li>状态 <ol><li>full</li><li>partial</li><li>empty</li></ol></li><li>体积限制 <ol><li><code>Buffer.poolSize = 8*1024</code></li></ol></li></ol><p><strong>buffer 分配内存总结：</strong></p><ol><li>在初次加载时就会初始化 1 个 <strong>8KB 的内存空间</strong></li><li>根据申请的内存大小分为 <strong>小 Buffer 对象</strong> 和 <strong>大 Buffer 对象</strong><ol><li>大于 buffer.poolSize / 2，为大 buffer 对象，小于则为小 buffer 对象</li></ol></li><li>小 Buffer 情况，会继续判断这个 slab 空间是否足够 <ul><li>如果空间足够就去使用剩余空间同时更新 slab 分配状态，偏移量会增加</li><li>如果空间不足，slab 空间不足，就会去创建一个新的 slab 空间用来分配</li></ul></li><li>大 Buffer 情况，则会直接走 createUnsafeBuffer(size) 函数</li><li>不论是小 Buffer 对象还是大 Buffer 对象，内存分配是在 C++ 层面完成，内存管理在 JavaScript 层面，最终还是可以被 V8 的垃圾回收标记所回收。</li></ol>',20),f={},i=(0,r(744).Z)(f,[["render",function(e,l){return a}]])},744:(e,l)=>{l.Z=(e,l)=>{for(const[r,a]of l)e[r]=a;return e}}}]);